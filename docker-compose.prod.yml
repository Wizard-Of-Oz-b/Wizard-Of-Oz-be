# Compose v2 (version 키 불필요)

# 공통 로그 롤링
x-logging: &tight-logging
  driver: json-file
  options:
    max-size: "5m"
    max-file: "2"

# 파이썬/메모리 친화 env
x-py-memenv: &py-memenv
  MALLOC_ARENA_MAX: "2"
  PYTHONDONTWRITEBYTECODE: "1"
  PYTHONUNBUFFERED: "1"

services:
  web:
    image: wizard-of-oz-be:app
    build:
      context: .
      dockerfile: Dockerfile.prod
    container_name: wizard-of-oz-be-web-1
    command:
      - uv
      - run
      - gunicorn
      - config.wsgi:application
      - --worker-class
      - gthread
      - --workers
      - "1"
      - --threads
      - "1"
      - --max-requests
      - "200"
      - --max-requests-jitter
      - "50"
      - --timeout
      - "30"
      - --graceful-timeout
      - "20"
      - --keep-alive
      - "3"
      - --log-level
      - warning
    env_file:
      - .env.prod
    environment:
      <<: *py-memenv
    expose:
      - "8000"                               # 내부통신만 (외부는 nginx:80)
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://127.0.0.1:8000/healthz/ >/dev/null || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 3
    deploy:
      resources:
        limits: { memory: "300m" }
        reservations: { memory: "200m" }
    logging: *tight-logging
    networks: [appnet]
    restart: unless-stopped

  worker:
    image: wizard-of-oz-be:app
    container_name: wizard-of-oz-be-worker-1
    env_file:
      - .env.prod
    environment:
      MALLOC_ARENA_MAX: "2"
      PYTHONDONTWRITEBYTECODE: "1"
      PYTHONUNBUFFERED: "1"
    depends_on:
      redis:
        condition: service_healthy
    command:
      - bash
      - -lc
      - |
        set -euo pipefail
        echo "[worker] booting…"

        # 1) DNS 준비
        until getent hosts redis >/dev/null 2>&1; do
          echo "[worker] waiting DNS"; sleep 1;
        done

        # 2) TCP 오픈 대기 (패키지 없이 /dev/tcp 활용, 30초 제한)
        timeout 30 bash -c '
          until (</dev/tcp/redis/6379) 2>/dev/null; do
            echo "[worker] waiting TCP"; sleep 1;
          done
        ' || { echo "[worker] TCP wait timeout"; exit 1; }

        # 3) Celery 실행(PID1 교체)
        exec uv run celery -A config worker -B --pool=solo --loglevel=warning \
          --concurrency=1 --prefetch-multiplier=1 --max-tasks-per-child=100
    deploy:
      resources:
        limits: { memory: "240m" }
        reservations: { memory: "150m" }
    restart: unless-stopped
    networks: [ appnet ]
    logging:
      driver: json-file
      options: { max-size: "5m", max-file: "2" }

  redis:
    image: redis:7
    container_name: wizard-of-oz-be-redis-1
    command: ["redis-server",
      "--appendonly", "no",
      "--maxmemory", "64mb",
      "--maxmemory-policy", "allkeys-lru"]
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 3s
      timeout: 2s
      retries: 10
      start_period: 5s
    deploy:
      resources:
        limits: { memory: "64m" }
        reservations: { memory: "32m" }
    logging: *tight-logging
    networks: [appnet]
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    container_name: wizard-of-oz-be-nginx-1
    depends_on:
      web:
        condition: service_healthy
    ports:
      - "80:80"
    volumes:
      - ./infra/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./:/app:ro                         # 정적/미디어 파일 서빙 시 사용
    deploy:
      resources:
        limits: { memory: "48m" }
        reservations: { memory: "24m" }
    logging: *tight-logging
    networks: [appnet]
    restart: unless-stopped

networks:
  appnet:
